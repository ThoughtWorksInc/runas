# Runas, passo 5: busca por palavras inteiras

A vers√£o MVP1 do programa `runas` busca caracteres comparando uma substring do nome. Isso gera dois problemas: baixa precis√£o e baixa re

* Resultados demais: pesquisando "cat" v√™m 82 caracteres, sendo que a maioria n√£o tem nada a ver com gatos, por exemplo "MULTIPLICATION SIGN".
* Resultados de menos: a ordem das palavras na consulta deveria ser ignorada: "chess black" e "black chess" deveriam devolver os mesmos resultados, e "cat smiling" deveria encontrar todos estes caracteres:

```
U+1F638 üò∏ 	GRINNING CAT FACE WITH SMILING EYES
U+1F63A üò∫ 	SMILING CAT FACE WITH OPEN MOUTH
U+1F63B üòª 	SMILING CAT FACE WITH HEART-SHAPED EYES
```

> __TEORIA__: na √°rea de recupera√ß√£o de informa√ß√£o (_information retrieval_) esses problemas s√£o caracterizados por duas m√©tricas: [precis√£o e revoca√ß√£o](https://pt.wikipedia.org/wiki/Precis%C3%A3o_e_revoca%C3%A7%C3%A3o) (_precision_, _recall_). Resultados demais √© falta de precis√£o: o sistema est√° recuperando resultados irrelevantes, ou encontrando falsos positivos. Resultados de menos √© falta de revoca√ß√£o: o sistema est√° deixando de recuperar resultados relevantes, ou seja, falsos negativos.

Vamos melhorar a precis√£o e a revoca√ß√£o pesquisando sempre por palavras inteiras. Poder√≠amos resolver o problea todo mexendo apenas na fun√ß√£o `Listar`, mas isso deixaria ela muito grande e dif√≠cil de testar. Ent√£o vamos colocar um pouco das novas funcionalidades na fun√ß√£o `AnalisarLinha` e em outras fun√ß√µes que criaremos aos poucos.

## Melhorias em `AnalisarLinha`

Em vez de devolver apenas o c√≥digo e o nome do caractere, vamos fazer a fun√ß√£o `AnalisarLinha` devolver tamb√©m as palavras do nome, na forma de uma fatia de strings, ou seja, uma `[]string`.

Para come√ßar, mudamos o teste `TestAnalisarLinha`:

```go
func TestAnalisarLinha(t *testing.T) {
	runa, nome, palavras := AnalisarLinha(linhaLetraA)
	if runa != 'A' {
		t.Errorf("Esperava 'A', veio %q", runa)
	}
	const nomeA = "LATIN CAPITAL LETTER A"
	if nome != nomeA {
		t.Errorf("Esperava %q, veio %q", nomeA, nome)
	}
  palavrasA := []string{"LATIN", "CAPITAL", "LETTER", "A"} // ‚ûä
	if ! reflect.DeepEqual(palavras, palavrasA) { // ‚ûã
		t.Errorf("\n\tEsperado: %q\n\trecebido: %q", palavrasA, palavras) // ‚ûå
	}
}
```
